[gd_scene load_steps=2 format=3 uid="uid://0gyt7cd5qkm4"]

[sub_resource type="GDScript" id="GDScript_erwky"]
script/source = "extends Node
class_name GenericPhysicsComponent

@onready var parent : CharacterBody3D = get_parent()
@onready var parent_collision = parent.find_child(\"CollisionShape3D\")
@onready var step_cast : ShapeCast3D = $StepCast
@onready var step_ray : RayCast3D = $StepRay

@export var speed : float = 1
@export var friction : float = 0.9
@export var gravity : float = 0.55
@export var step_height_up : float = 1
@export var step_height_down : float = 1

var on_ground_prev : bool = true
var on_ground : bool = true
var on_ground_force : bool = false

func _ready():
	# reapply the defaults, fuck their propeties dsajhdjkahkl
	parent.floor_block_on_wall = true
	parent.floor_constant_speed = true
	parent.floor_max_angle = 0.75
	parent.floor_snap_length = 0.2
	parent.floor_stop_on_slope = true
	parent.max_slides = 6
	parent.motion_mode = 0
	parent.platform_floor_layers = 4294967295
	parent.platform_on_leave = 0
	parent.platform_wall_layers = 0
	parent.safe_margin = 0.001
	parent.slide_on_ceiling = true
	parent.up_direction = Vector3.UP
	parent.velocity = Vector3.ZERO
	parent.wall_min_slide_angle = 0.15
	
func is_on_ground():
	return on_ground_force or parent.is_on_floor()

func snap_to_stair( delta: float ):
	var global_position_pre : Vector3 = parent.global_position
	step_cast.global_position.x = parent.global_position.x + parent.velocity.x * delta
	step_cast.global_position.z = parent.global_position.z + parent.velocity.z * delta
	step_cast.global_position.y = step_height_up + ( step_cast.shape.height / 2 ) + parent.global_position.y
	step_cast.target_position.y = -step_height_up + -step_height_down
	step_cast.shape = parent_collision.shape

	if not ( on_ground_prev or on_ground ):
		return

	# checks
	var query = PhysicsShapeQueryParameters3D.new()
	query.exclude = [ parent ]
	query.shape = parent_collision.shape
	query.transform = step_cast.global_transform
	var result = parent.get_world_3d().direct_space_state.intersect_shape( query, 1 )

	step_cast.force_shapecast_update()

	if not step_cast.is_colliding() or parent.velocity.y > 01:
		on_ground_force = false
		return
	else:
		on_ground_force = true

	if result:
		return

	var step_position = step_cast.get_collision_point(0)
	var step_height = step_position.y - parent.global_position.y

	#  gets angle using raycasting ( shapecast has very inacurate normals )
	step_ray.global_position = Vector3( step_position.x, step_position.y + 0.5, step_position.z )
	step_ray.force_raycast_update()
	var step_angle = step_ray.get_collision_normal().angle_to( Vector3.UP )

	# avoids climping slopes too steep
	if step_angle > parent.floor_max_angle:
		return
	
	# avoids snaping to the same floor
	if abs( step_height ) < 0.01:
		return

	# known issues:
	# can snap multiple times between frames, snaps on slopes cases slight jitter.
	# i won't fix them, im tired of working on stair climbing :<

	# snap node3D
	parent.velocity.y = 0
	parent.global_position.y = step_cast.get_collision_point(0).y
	
	if parent is Player:
		parent.player_view_step_offset -= parent.global_position.y - global_position_pre.y

func _physics_process( delta: float ) -> void:
	on_ground_prev = on_ground
	on_ground = is_on_ground()

	# gravity
	parent.velocity.y += -gravity

	# friction
	parent.velocity.x *= friction
	parent.velocity.z *= friction
	
	snap_to_stair( delta )
	parent.move_and_slide()

	if parent.position.y < -500:
		if parent is Player:
			# ops... sorry about that
			parent.global_position = global.player_position
			parent.global_rotation.y = global.player_rotation.y
			parent.camera.global_rotation.x = global.player_rotation.x
		else:
			global.kill( parent )
"

[node name="GenericPhysicsComponent" type="Node"]
script = SubResource("GDScript_erwky")
